#### 正则表达式：

用于字符串模糊匹配的

 （字符x *） 表示x出现0次或多次 

 （字符x +） 表示x出现1次或多次 

 （字符x？） 表示x出现0次或1次 

^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。

  /^表示匹配输入字符串开始的位置，,  $/表示匹配输入字符串结束位置

\d 表示数字   \w表示 匹配字母或数字或下划线 `a-z  A-Z 0-9 _     `  \s 匹配任意的空白符

  小数点 ‘.’   可以匹配除了换行符(/n)以外的任意一个字符

"ab*"：表示一个字符串有一个a后面跟着零个或若干个b。（"a", "ab", "abbb",……）；
 "ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多；（ "ab", "abbb",……）；
 "ab?"：表示一个字符串有一个a后面跟着零个或者一个b； （"a", "ab",……）；

牛客上有道例题可以看下

\d{n}   可以是n个不同的数字，不是仅局限于n个相同的数字

#### 动规

动态规划的出发点在于选和不选
目前都可以看是比递归更加高级
给定一堆的数字，怎么选择一些不相邻的数字，使找出最大的和
给定一个数组 [4 1 2 9 1]  4 +9=13

```
int RecSolution(vector<int> & v,int i)
{
	//递归出口  i=0 return v[0]  i=1  return max(v[0],v[1])
	if (i == 0)
		return v[0];
	else if (i == 1)
		return max(v[0], v[1]);
	//递归方程   max(OPT(i-2)+v[i],OPT(i-1))
	else
	{
		int A = RecSolution(v, i - 2) + v[i];//这里是不能选相邻的两个 所以先v[i],则是v[i]+     
		int B= RecSolution(v, i - 1);       //RecSolution(v, i - 2) 
		return max(A, B);
	}

}
int DpSolution(vector<int> & v)
{
	vector<int> tmp;
	tmp.resize(v.size());
	tmp[0] = v[0];
	tmp[1]= max(v[0], v[1]);
	for (int i = 2; i < v.size(); i++) {
		int A = tmp[i - 2] + v[i];//状态转移方程
		int B = tmp[i - 1];
		tmp[i]=max(A, B);
	}
	return tmp[v.size() - 1];
}
void main()
{
	vector<int> v = { 1,2,4,1,7,8,3 };
	cout << RecSolution(v,v.size()-1) << endl;
	cout << DpSolution(v) << endl;

}
```


给定一个数组，在给定一个数字，判断其某些数组元素加起来是否可以等于S,等于返回true,找不到返回false

```
bool RecSolution(vector<int> & v,int i,int S)
{
	if (i == 0)
		return v[0] == S;
	else if (S == 0)
		return true;
	else if (v[i] > S)
		return RecSolution(v, i - 1, S);
	else
		return (RecSolution(v, i - 1, S - v[i]) || RecSolution(v, i - 1, S));
}
bool DpSolution(vector<int> & v,int S)
{
	bool subset[6][10];
	for (int i = 0; i < 6; i++)
		subset[i][0] = true;
	for (int j = 0; j < 10; j++)
		subset[0][j] = false;
	subset[0][v[0]] = true;
	for (int i = 1; i < 6; i++)
	{
		for (int j = 1; j < 10; j++)
		{
			if (v[i] > S)
				subset[i][j] = subset[i-1][j];
			else
			{
				int A = subset[i - 1][j];
				int B = subset[i - 1][j-v[i]];
				subset[i][j] = A || B;
			}
		}
	}
	return subset[5][9];
}
void main()
{
	vector<int> v = { 3,34,4,12,5,2 };
	int S = 9;
	cout << RecSolution(v,v.size()-1,S) << endl;
	cout << DpSolution(v,S) << endl;

}
```


找零钱问题，返回需要的最小个数(假设每种硬币无限)
递归

```
int RecSolution(vector<int> & v, int S)//最少需要几个数
{
	int res = INT_MAX;
	int this_res;
	//递归出口
	if (S == 0)
		return 0;
	for(auto coin:v)
	{
		if (S >= coin)//如果选coin
			this_res = RecSolution(v, S - coin);
		if (this_res == -1)
			continue;
		else
			res = min(this_res + 1, res);
	}
	if (res == INT_MAX)
		return -1;
	return res;
	//状态转移方程  min(f(v,i-1,S-v[i]),f(v,i-1,S))
}
//带记事本的递归
int MemRecSolution(vector<int> & v, int S)//最少需要几个数
{
	vector<int> mem(S + 1);
	if (mem[S] != 0)
		return mem[S];
	int res = INT_MAX;
	int this_res;
	//递归出口
	if (S == 0)
	{
		mem[S] = 0;
		return 0;
	}
	for (auto coin : v)
	{
		if (S >= coin)//如果选coin
			this_res = RecSolution(v, S - coin);
		if (this_res == -1)
			continue;
		else
			res = min(this_res + 1, res);
	}
	if (res == INT_MAX)
	{
		mem[S] = -1;
		return -1;
	}
	return res;
	//状态转移方程  min(f(v,i-1,S-v[i]),f(v,i-1,S))
}
//动态规划
int DpSolution(vector<int>& v, int amount)
{
	vector<int> dp(amount + 1, INT_MAX -1);
	dp[0] = 0;
	for (int coin : v)
	{
		for (int i = coin; i <= amount; ++i)
		{
			dp[i] = min(dp[i], dp[i - coin] + 1);
		}
	}
	return dp[amount] >= INT_MAX ? -1 : dp[amount];
}
void main()
{
	vector<int> v = { 1,2,5,4,8 };
	int S = 10;
	cout << RecSolution(v, S) << endl;
	cout << MemRecSolution(v, S) << endl;
	cout << DpSolution(v, S) << endl;

​```
//cout << DpSolution(v, S) << endl;
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

链接：https://leetcode-cn.com/problems/coin-change

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
            //类似于完全背包必须装满的问题
            vector<int> dp(amount+1,amount+2);//初始化为不可能取到的值，求最小我们就初始换为最大
           for(auto coin:coins)
           {
               for(int i=coin; i<amount; i++)
               {
                   if(dp[i-coin]==amount+)
                       continue;
                   dp[i]=min(dp[i],dp[i-coin]+1)';'
               }
           }
        return (dp[amount]==amount+2)？-1：dp[amount]；
    }
}
```




##### 零钱兑换

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 https://leetcode-cn.com/problems/coin-change-2/

类似于完全背包问题  `dp[i][j]=dp[i-1][j]+dp[i-1][j-coins[i]]`

注意初始化时dp[0]=1,这里是使当coin=1时，可以理解为初始化，可以转移为1；

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
       vector<int> dp(amount+1,0);
       dp[0]=1;
        for(auto v:coins)
            for(int i=coins[i]; i<=amount;i++)
                dp[i]=dp[i]+dp[i-v];
    }
    return dp[amount];
};
```

#### 二叉树

二叉搜索树（BST   binary search tree）： 左子树的值 <  根的值 <右子树的值   （中序遍历是按从小到大排列）

```
typedef struct node {
	int data;
	struct node* left;
	struct node* right;
} Node;
typedef struct {
	Node* root;
}Tree;
void preorder(Node* node)
{
	if (node != NULL)
	{
		printf("%d", node->data);
		preorder(node->left);
		preorder(node->right);
	}
}
void inorder(Node* node)//中序遍历
{
	if (node != NULL)
	{
		inorder(node->left);
		printf("%d", node->data);
		inorder(node->right);
	}
}
//void postorder(Node* node)//中序遍历
void insert(Tree* tree, int value)
{
	Node* node = (Node*)malloc(sizeof(Node));
	assert(node);
	node->data = value;
	node->left = NULL;
	node->right = NULL;
	if (tree->root == NULL)
		tree->root = node;
	else
	{
		Node* tmp = tree->root;
		while (tmp != NULL)
		{
			if (value < tmp->data)
			{
				if (tmp->left == NULL)
				{
					tmp->left = node;
					return;
				}
				else
					tmp = tmp->left;
			}
			else if (value > tmp->data)
			{
				if (tmp->right == NULL)
				{
					tmp->right = node;
					return;
				}
				else
					tmp = tmp->right;
			}
		}
	}
}
int get_height(Node* node)
{
	if (node == NULL)
		return -1;
	int left = get_height(node->left);
	int right = get_height(node->right);
	return max(left, right) + 1;

}
int get_maximumdata(Node* node)
{
	if (node == NULL)
		return -1;
	int max1 = node->data;
	int max2 = get_maximumdata(node->left);
	int max3 = get_maximumdata(node->right);
	int max = max1;
	if (max < max2) max = max2;
	if (max < max3) max = max3;
	return max;
}
int main()
{
	int arr[7] = { 6,3,8,2,5,1,7 };
	Tree tree;
	tree.root = NULL;
	int i;
	for (int i = 0; i < 7; i++)
	{
		insert(&tree, arr[i]);
	}
	inorder(tree.root);
	cout << endl;
	cout << "--------------------------" << endl;
	preorder(tree.root);
	cout << endl;
	cout << get_height(tree.root) << endl;
	cout << get_maximumdata(tree.root) << endl;
}
```

#### 区间dp问题

动态规划：（如果不相邻就变为了贪心问题）
合并堆消费体力问题，每次只能合并相邻的两个堆，消耗的体力为两个堆个数之和，求最少消费的体力
比如 5 8 9 3   
5+8=13  消费13体力  13 9 3 
9+3=12   消费12体力  13 12
13+12=25  消费25体力
总体力消耗为 13+12+25=50

1、状态表示：  `dp[[i][j]`代表从第i堆到第j堆这个区间合并为一堆消耗的体力
2、状态计算：化整为0  `dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+s[j]-s[i-1])`

```
	const int N = 310;
	int n;
	int s[N];//前缀和
	int dp[N][N];
	int main()
	{
		cin >> n;
		for (int i = 1; i <= n; i++) cin >> s[i], s[i] += s[i - 1];
		for(int len=2;len<=n;len++)//（当len=1时说明只有一堆，直接返回）区间dp   先枚举区间长度，再                                     //枚举区间范围
			for (int i = 1; i + len - 1 <= n; i++)
			{
				int j = i + len - 1;
				dp[i][j] = 1e8;
				for (int k = j; k < j; k++)
					dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1]);
			}
		cout << dp[1][n] << endl;//最终需要求出从1-n范围的
	}
```

#### 全排列存在重复数据

给定一个可包含重复数字的序列，返回所有不重复的全排列https://leetcode-cn.com/problems/permutations-ii/

和不存在重复数据的全排列代码类似，就只是去掉重复数据

` if(i>0&&nu[i-1]==nu[i]&&!vis[i-1]) continue;`

思想是：nu[i]和nu[i-1]相等时，当递归到nu[i]时，判断nu[i-1]是否已经被选择了，如果选择了,则继续向下执行

如果没有被选择，则continue

考虑元素组1 1 2 的全排列，去掉重复项

![asd2](E:\duzhiqiang\比特51c语言\github\C-PULS-PULS\asd2.jpg)

这里的和前一位相等代表的是真正意义上数组地下标

还要注意一点是必须先sort()，再dfs,因为这样才能将重复的元素压缩到一块进行剪枝

```c++
class Solution {
public:
vector<int> nu;
vector<int> nans;
vector<vector<int>> ans;
vector<int> vis;
int n;
void dfs(int cur){
    if(cur==n) {
        ans.push_back(nans);
        return;
    }
    else{
        for(int i=0;i<n;i++){
            if(vis[i]==1) continue;
            if(i>0&&nu[i-1]==nu[i]&&!vis[i-1]) continue;
            vis[i]=1;
            nans[cur]=nu[i];
            dfs(cur+1);
            vis[i]=0;
        }
    }
}
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        if(nums.size()==0)
        return ans;
        n=nums.size();
        sort(nums.begin(),nums.end());
        nu=nums;
        nans.assign(n,0);
         vis.assign(n,0);
        dfs(0);
        return ans;
    }
};
```

