#### 正则表达式：

用于字符串模糊匹配的

 （字符x *） 表示x出现0次或多次 

 （字符x +） 表示x出现1次或多次 

 （字符x？） 表示x出现0次或1次 

^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。

  /^表示匹配输入字符串开始的位置，,  $/表示匹配输入字符串结束位置

\d 表示数字   \w表示 匹配字母或数字或下划线 `a-z  A-Z 0-9 _     `  \s 匹配任意的空白符

  小数点 ‘.’   可以匹配除了换行符(/n)以外的任意一个字符

"ab*"：表示一个字符串有一个a后面跟着零个或若干个b。（"a", "ab", "abbb",……）；
 "ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多；（ "ab", "abbb",……）；
 "ab?"：表示一个字符串有一个a后面跟着零个或者一个b； （"a", "ab",……）；

牛客上有道例题可以看下

\d{n}   可以是n个不同的数字，不是仅局限于n个相同的数字

#### 动规

##### 零钱兑换

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 https://leetcode-cn.com/problems/coin-change-2/

类似于完全背包问题  `dp[i][j]=dp[i-1][j]+dp[i-1][j-coins[i]]`

注意初始化时dp[0]=1,这里是使当coin=1时，可以理解为初始化，可以转移为1；

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
       vector<int> dp(amount+1,0);
       dp[0]=1;
        for(auto v:coins)
            for(int i=coins[i]; i<=amount;i++)
                dp[i]=dp[i]+dp[i-v];
    }
};
```

