#### 正则表达式：

用于字符串模糊匹配的

 （字符x *） 表示x出现0次或多次 

 （字符x +） 表示x出现1次或多次 

 （字符x？） 表示x出现0次或1次 

^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。

  /^表示匹配输入字符串开始的位置，,  $/表示匹配输入字符串结束位置

\d 表示数字   \w表示 匹配字母或数字或下划线 `a-z  A-Z 0-9 _     `  \s 匹配任意的空白符

  小数点 ‘.’   可以匹配除了换行符(/n)以外的任意一个字符

"ab*"：表示一个字符串有一个a后面跟着零个或若干个b。（"a", "ab", "abbb",……）；
 "ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多；（ "ab", "abbb",……）；
 "ab?"：表示一个字符串有一个a后面跟着零个或者一个b； （"a", "ab",……）；

牛客上有道例题可以看下

\d{n}   可以是n个不同的数字，不是仅局限于n个相同的数字

#### 动规

##### 零钱兑换

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 https://leetcode-cn.com/problems/coin-change-2/

类似于完全背包问题  `dp[i][j]=dp[i-1][j]+dp[i-1][j-coins[i]]`

注意初始化时dp[0]=1,这里是使当coin=1时，可以理解为初始化，可以转移为1；

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
       vector<int> dp(amount+1,0);
       dp[0]=1;
        for(auto v:coins)
            for(int i=coins[i]; i<=amount;i++)
                dp[i]=dp[i]+dp[i-v];
    }
};
```

#### 二叉树

二叉搜索树（BST   binary search tree）： 左子树的值 <  根的值 <右子树的值   （中序遍历是按从小到大排列）

```
typedef struct node {
	int data;
	struct node* left;
	struct node* right;
} Node;
typedef struct {
	Node* root;
}Tree;
void preorder(Node* node)
{
	if (node != NULL)
	{
		printf("%d", node->data);
		preorder(node->left);
		preorder(node->right);
	}
}
void inorder(Node* node)//中序遍历
{
	if (node != NULL)
	{
		inorder(node->left);
		printf("%d", node->data);
		inorder(node->right);
	}
}
//void postorder(Node* node)//中序遍历
void insert(Tree* tree, int value)
{
	Node* node = (Node*)malloc(sizeof(Node));
	assert(node);
	node->data = value;
	node->left = NULL;
	node->right = NULL;
	if (tree->root == NULL)
		tree->root = node;
	else
	{
		Node* tmp = tree->root;
		while (tmp != NULL)
		{
			if (value < tmp->data)
			{
				if (tmp->left == NULL)
				{
					tmp->left = node;
					return;
				}
				else
					tmp = tmp->left;
			}
			else if (value > tmp->data)
			{
				if (tmp->right == NULL)
				{
					tmp->right = node;
					return;
				}
				else
					tmp = tmp->right;
			}
		}
	}
}
int get_height(Node* node)
{
	if (node == NULL)
		return -1;
	int left = get_height(node->left);
	int right = get_height(node->right);
	return max(left, right) + 1;

}
int get_maximumdata(Node* node)
{
	if (node == NULL)
		return -1;
	int max1 = node->data;
	int max2 = get_maximumdata(node->left);
	int max3 = get_maximumdata(node->right);
	int max = max1;
	if (max < max2) max = max2;
	if (max < max3) max = max3;
	return max;
}
int main()
{
	int arr[7] = { 6,3,8,2,5,1,7 };
	Tree tree;
	tree.root = NULL;
	int i;
	for (int i = 0; i < 7; i++)
	{
		insert(&tree, arr[i]);
	}
	inorder(tree.root);
	cout << endl;
	cout << "--------------------------" << endl;
	preorder(tree.root);
	cout << endl;
	cout << get_height(tree.root) << endl;
	cout << get_maximumdata(tree.root) << endl;
}
```

