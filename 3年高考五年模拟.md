

#### [187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)

所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

```c++
class Solution {
public:
/*
使用map<string ,int> 也就是hash桶，跟我们之前做的查看一个数组中出现多次的的数字思想一样，
只是将数字转换为字符串
*/
    vector<string> findRepeatedDnaSequences(string s) {
        int k=10;
        unordered_map<string,int> mp;
        vector<string> ret;
        if (s.size() < k + 1)
            return ret;
        for(int i=0;i<=s.size()-k;i++){//注意临界条件	
            mp[s.substr(i,10)]++;
        }
        for(auto e:mp)
        {
            if(e.second>1)
            ret.push_back(e.first);
        }
        return ret;
    }
};
```

#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。

思路1：暴力解法，从0->A.size()-1暴力枚举每一段数组的起点和终点 

思路1：前缀和·，

```
class Solution {
public:
    int subarraysDivByK(vector<int>& A, int K) {
        //暴力解法
        int count=0;
        for(int i=0;i<A.size();i++)
        {
            int tmp=0;
            for(int j=i;j<A.size();j++)
            {
                tmp+=A[j];
                if(tmp%K==0)
                    count++;
            }
        }
        return count;
    }
};
```

#### [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)

```
class Solution {
public:
    bool divisorGame(int N) {
        return N%2==0;
    }
};
```

#### 用一个栈实现另一个栈的排序

栈中元素是从小到大排列的

```
 /* 待排序的栈stack， 辅助栈help。 在stack上执行pop操作，记元素为cur
 if cur <= 【help 的栈顶元素】，cur 压入help栈中；
 else cur > 【help 的栈顶元素】，逐一弹出help， 直到cur <= 【help 的栈顶元素】，在将cur压入help
 一直执行以上操作，直到stack中的全部元素都导入help栈中，（此时从栈顶到栈底：有小到大），最后，将help栈中的元素，pop一下，排序
     */
#include<iostream>
#include<stack>
using namespace std;
void mysort(stack<int>& st)
{
	stack<int> help;
	while (!st.empty())
	{
		int cur = st.top();
		st.pop();
		while (!help.empty() && cur > help.top())
		{
			st.push(help.top());
			help.pop();
		}
		help.push(cur);
	}
	while (!help.empty())
	{
		st.push(help.top());
		help.pop();
	}
}

int main()
{
	stack<int> st;
	int n;
	while (cin >> n)
	{
		for (int i = 0; i < n; i++)
		{
			int tmp;
			cin >> tmp;
			st.push(tmp);
		}
		mysort(st);
		for (int i = 0; i < n; i++)
		{
			cout << st.top() << " ";
			st.pop();
		}
	}
}
```

#### 大整数相除

![大整数相乘](E:\duzhiqiang\我的编程资料和代码\github\picture\大整数相乘.png)

```
/*
思路：将整数转化为字符串，按每个字符串这样的进行相乘，将结果保存在数组里，先不考虑进位，第一次乘完后，在第二次从后向前遍历，考虑进位
s[i]，字符转整形  int tmp=s[i]-'0';
整形转字符   string res=to_string(tmp)
*/

string mult(string s1, string s2)
{
	vector<int> ret(s1.size()+s2.size()-1,0);
	for (int i = 0; i < s1.size(); i++)
	{
		for (int j = 0; j < s2.size(); j++)
		{
			ret[i + j] += (s1[i] - '0')*(s2[j] - '0');
		}
	}
	int flag = 0;
	string res;
	for (int i = ret.size() - 1; i >0; i--)
	{
		int tmp = ret[i]+ flag;
		flag = tmp / 10;
		res = to_string(tmp % 10) + res;
	}
	res = to_string(ret[0] + flag)+res;
	return res;
}
```

![1598185448677](E:\duzhiqiang\我的编程资料和代码\github\picture\LRU.png)

#### LRU算法·

```

/*
使用双向循环链表和hashmap  定义capacity
hashmap存储数据
双向循环链表存储数据的位置，位置越靠前说明最近使用，越靠后说明最近最久未使用，
当get数据时，使用hashmap查找,找不到返回-1，找到则把该节点置换到头节点
当使用put时，使用hashmap查找,找到则更新val值且将其置换到头节点，找不到则先判断数据容量是否超过capacity,超过的话先删除最近最久未使用的节点(也就是尾节点)，随后将新
节点插入到头节点
*/
class BCListNode{
public:
BCListNode(int _key,int _val):key(_key),val(_val)
{}
 public:
 int val;
 int key;
 BCListNode* next;
 BCListNode* front;
};
class LRUCache {
private:
  int _capacity;
  BCListNode* head;
   BCListNode* tail;
   unordered_map<int,BCListNode*> mp;
public:
    LRUCache(int capacity) {
        _capacity=  capacity;    
         head=new BCListNode(0,0);
         tail=new BCListNode(0,0);
         head->next=tail;
         tail->front=head;
    }
    int get(int key) {
        if(mp.count(key))//如果存在，将对应的节点移动到头节点
        {     
            BCListNode* tmp=mp[key];
            tmp->front->next=tmp->next;
            tmp->next->front=tmp->front;
             AddToHead(tmp);
             return tmp->val;
        }
        else
        return -1;
    }
    
    void put(int key, int value) {
        if(mp.count(key)==0)  //如果该节点不存在
        {
        //将节点加到头节点
             BCListNode* newnode=new BCListNode(key,value);
             AddToHead(newnode);
              mp.insert(make_pair(key,newnode));
            //判断是否超过capacity,超过删除尾节点
            if(mp.size()==_capacity)
            {
                BCListNode* tmp=tail->front;
                tmp->front->next=tail;
                tail->front=tmp->front;
                mp.erase (tmp->key);
                delete tmp;
                AddToHead(newnode);
                mp.insert(make_pair(key,newnode));
            }
        }
        else//如果节点存在
        {
            BCListNode* tmp=mp[key];
            tmp->front->next=tmp->next;
            tmp->next->front=tmp->front;
            AddToHead(tmp);
            tmp->val=value;
        }
    }
    private:
    void  AddToHead(BCListNode* newnode)
    {
       newnode->next=head->next;
       head->next=newnode;
       head->next->front=head;
       newnode->next->front=newnode;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

#### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

![1598264363115](E:\duzhiqiang\我的编程资料和代码\github\picture\leetcode459.png)

```
//思路：暴力，只需遍历到n/2出即可，
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        bool ret;
        int n=s.size();
        for(int i=0;i<s.size()/2;i++)
        {
            if(n%(i+1)==0)
            {
                string tmp=s.substr(0,i+1);
                ret=true;
                for(int j=i+1;j<s.size();j+=(i+1))
                {
                    if(tmp!=s.substr(j,i+1))
                       {
                            ret=false;
                           break;
                       }
                }
                if(ret) 
                {
                    return true;
                }
            }
        }
        return ret;
    }
};
```

#### 深信服笔试[编程题]出栈顺序 

已知某一个字母序列，把序列中的字母按出现顺序压入一个栈，在入栈的任意过程中，允许栈中的字母出栈，求所有可能的出栈顺序

##### **输入描述:**

```
字符串，如：abc
```

##### **输出描述:**

```
可能的出栈顺序，每行一种顺序
```

##### **输入例子1:**

```
abc
```

##### **输出例子1:**

```
abc
acb
bac
bca
cba
```

```
/*
思路：先做出所有字符的全排列，然后编写一个check函数，判断这个排列是否满足出栈顺序
这个check函数就是利用一个栈模拟出栈，第一个循环中压入源字符串，在第二个循环中，模拟出栈，当nans[j]==st.top() 时，出栈，st.pop(),并且j++；否则，跳过第二个循环。最后只需要判断栈是否为空即可
*/
#include<iostream>
#include<vector>
#include<string>
#include<stack>
using namespace std;

vector<string> v;
string nans;
vector<int> vis;
bool check(string& s, string& nans)
{
	stack<char>st;
	bool ret = true;
	int j=0;
	for (int i = 0; i < s.size(); i++)
	{
		st.push(s[i]);
		while (j < nans.size())
		{
			if (!st.empty() && st.top() == nans[j])
			{
				j++;
				st.pop();
			}
			else
				break;
		}
	}
	if (!st.empty()) ret = false;
	return ret;
}
void permutation(int pos,string& s)
{
	if (pos == s.size())
	{
		if (check(s,nans))
		{
			v.push_back(nans);
		}
		return;
	}
	for (int i = 0; i < s.size(); i++)
	{
		if (vis[i] == 0)
		{
			vis[i] = 1;
			nans.push_back(s[i]);
			permutation(pos + 1, s);
			vis[i] = 0;
			nans.pop_back();

		}
	}
}
int main()
{
	string s;
	while (getline(cin,s))
	{
		//全排列
		vis.assign(s.size(), 0);
		permutation(0,s);
		for (auto e : v)
			cout << e << endl;
	}
}


```

#### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)（每日一题）

![1598344994912](E:\duzhiqiang\我的编程资料和代码\github\picture\lt491.png)

```
/*
思路：组合的思想，将所有nans.size()>=2的条件投列出来，然后check（）,检测是否是一个递增的序列，需要使用set去重
*/

class Solution {
public:
vector<vector<int>> ans;
vector<int> nans;
set<vector<int>> st;
bool check(vector<int>& nans)
{
	bool ret = true;
	for (int i = 1; i < nans.size(); i++)
	{
		if (nans[i] - nans[i - 1] < 0)
		{
			ret = false;
			break;
		}
	}
	return ret;
}
void dfs(int pos, vector<int>& nums)
{
	if (nans.size() >= 2)
	{
		if (check(nans))
			st.insert(nans);
	}
	if (pos == nums.size()) return;
	for (int i = pos; i < nums.size(); i++)
	{
		nans.push_back(nums[i]);
		dfs(i + 1,nums);
		nans.pop_back();
	}

}
vector<vector<int>> findSubsequences(vector<int>& nums) {
	if (nums.size() == 0) return ans;
	dfs(0, nums);
	for (auto e : st)
		ans.push_back(e);
	return ans;
}
};
```

#### 并查集

并查集判断图上是否存在环，且进行秩优化。。。

```
/*
并查集：可以检测图上是否有环，或者时有几个环（即有几个小团体）
*/

#define N 6
vector<int> parent(N, -1);
vector<int> ranks(N, -1);
int find(int  x)
{
	while (parent[x] != -1)
	{
		x = parent[x];
	}
	return x;
}
 
bool unique(int x, int y)
{
	int xx = find(x);
	int yy = find(y);
	if (xx == yy) return false;  //不需要合并，存在环
	if (ranks[xx] < ranks[yy])
		parent[xx] = yy;
	else if (ranks[xx] > ranks[yy])
		parent[yy] = xx;
	else if (ranks[xx] == ranks[yy])  //随便合并，但合并的一方秩要增加
	{
		parent[yy] = xx;//将yy合并到xx，xx的秩增加
		ranks[xx]++;
	}
	return true;
}
/* 代码中的图如下所示，1, 3, 4, 2组成一个环
	  *        0
	  *          \
	  *            1
	  *          /   \
	  *        2         3
	  *        |   \   |
	 *        5         4
	 */
int main()
{
	//建立一个图
	//邻接矩阵
	vector <vector<int>> graph(N,vector<int>(N,0));
	graph[0][1] = 1;
	graph[1][0] = 1;
	graph[1][2] = 1;
	graph[2][1] = 1;
	graph[1][3] = 1;
	graph[3][1] = 1;
	graph[3][4] = 1;
	graph[4][2] = 1;
	graph[2][4] = 1;
	graph[4][3] = 1;
	graph[2][5] = 1;
	graph[5][2] = 1;
	//或者是直接输入边 
    //int edges[6][2] = { {0, 1}, {1, 2}, {1, 3},
    //                     {2, 5}, {3, 4}, {2, 4} };// 图中所有的边集合
	for (int i = 0; i < N; i++)
	{
		for (int j = i; j < N; j++)
		{
			if (graph[i][j])
			{
				if (unique(i, j)==0)
				{
					cout << "存在环"<<endl;
					exit(0);
				}
			}
		}
	}
	cout << "不存在环" << endl;
}
```

#### [453. 最小移动次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)

![1598425973463](E:\duzhiqiang\我的编程资料和代码\github\picture\lt 453.png)


```c++
class Solution {
public:
    int minMoves(vector<int>& nums) {
        /*
        a1 a2 a3 排序好的三个数
        现在想使a1 =a2  则需要移动a2-a1步 count1=a2-a1;
        接下来 数组变为 a2 a2 a3+count1
        现在想使a2=a3+count1 则需要移动a3+count1-a2步 记为count2=a3+count1-a2=a3-a1
        则当n=3时，总的步骤为count1+count2=a2-a1+a3-a1;
        则规律产生：n=nums.size()时，总的步骤为a(n)-a1+a(n-1)-a1+...=sum(a1->a2)-n*a1

        */
        int sum=0;
        int minv=*min_element(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++)
        {
            sum+=(nums[i]-minv);
        }
        return sum;
    }
};
```
#### 深信服笔试  字符串替换
输入一组字符串 123456
输入n组数据
1 2
2 3
5 6
输出   3334566
```c++
//思路  
#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
#include<set>
#include<list>
using namespace std;
int main()
{
	int n;
	string s;
	while (getline(cin,s))
	{
		cin >> n;
		vector<vector<int>> v(n, vector<int>(2, 0));
		for (int i = 0; i < n; i++)
		{
			cin >> v[i][0]>>v[i][1];
		}
		vector<int> parent(10);
		for (int i = 0; i < 10; i++)
		{
			parent[i] = i;
		}
		for (int i = 0; i < n; i++)
		{
			if (parent[v[i][0]] != v[i][1])
			{
				parent[v[i][0]] = v[i][1];
			}
		}
		for (int i = 0; i < s.size(); i++)
		{
			if (parent[s[i] - '0'] != s[i] - '0')
				s[i] = parent[s[i] - '0'] + '0';
		}
		cout << s << endl;
	}
}

```


































