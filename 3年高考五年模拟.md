#### [187. 重复的DNA序列](https://leetcode-cn.com/problems/repeated-dna-sequences/)

所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

```c++
class Solution {
public:
/*
使用map<string ,int> 也就是hash桶，跟我们之前做的查看一个数组中出现多次的的数字思想一样，
只是将数字转换为字符串
*/
    vector<string> findRepeatedDnaSequences(string s) {
        int k=10;
        unordered_map<string,int> mp;
        vector<string> ret;
        if (s.size() < k + 1)
            return ret;
        for(int i=0;i<=s.size()-k;i++){//注意临界条件	
            mp[s.substr(i,10)]++;
        }
        for(auto e:mp)
        {
            if(e.second>1)
            ret.push_back(e.first);
        }
        return ret;
    }
};
```

#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。

思路1：暴力解法，从0->A.size()-1暴力枚举每一段数组的起点和终点 

思路1：前缀和·，

```
class Solution {
public:
    int subarraysDivByK(vector<int>& A, int K) {
        //暴力解法
        int count=0;
        for(int i=0;i<A.size();i++)
        {
            int tmp=0;
            for(int j=i;j<A.size();j++)
            {
                tmp+=A[j];
                if(tmp%K==0)
                    count++;
            }
        }
        return count;
    }
};
```

#### [1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)

```
class Solution {
public:
    bool divisorGame(int N) {
        return N%2==0;
    }
};
```

#### 用一个栈实现另一个栈的排序

栈中元素是从小到大排列的

```
#include<iostream>
#include<stack>
using namespace std;


void mysort(stack<int>& st)
{
	stack<int> help;
	while (!st.empty())
	{
		int cur = st.top();
		st.pop();
		while (!help.empty() && cur < help.top())
		{
			st.push(help.top());
			help.pop();
		}
		help.push(cur);
	}
	while (!help.empty())
	{
		st.push(help.top());
		help.pop();
	}
}

int main()
{
	stack<int> st;
	int n;
	while (cin >> n)
	{
		for (int i = 0; i < n; i++)
		{
			int tmp;
			cin >> tmp;
			st.push(tmp);
		}
		mysort(st);
		for (int i = 0; i < n; i++)
		{
			cout << st.top() << " ";
			st.pop();
		}
	}
}
```

#### 大整数相除

![大整数相乘](E:\duzhiqiang\我的编程资料和代码\github\picture\大整数相乘.png)

```
/*
思路：将整数转化为字符串，按每个字符串这样的进行相乘，将结果保存在数组里，先不考虑进位，第一次乘完后，在第二次从后向前遍历，考虑进位
s[i]，字符转整形  int tmp=s[i]-'0';
整形转字符   string res=to_string(tmp)
*/

string mult(string s1, string s2)
{
	vector<int> ret(s1.size()+s2.size()-1,0);
	for (int i = 0; i < s1.size(); i++)
	{
		for (int j = 0; j < s2.size(); j++)
		{
			ret[i + j] += (s1[i] - '0')*(s2[j] - '0');
		}
	}
	int flag = 0;
	string res;
	for (int i = ret.size() - 1; i >0; i--)
	{
		int tmp = ret[i]+ flag;
		flag = tmp / 10;
		res = to_string(tmp % 10) + res;
	}
	res = to_string(ret[0] + flag)+res;
	return res;
}
```

![1598185448677](E:\duzhiqiang\我的编程资料和代码\github\picture\LRU.png)

```

/*
使用双向循环链表和hashmap  定义capacity
hashmap存储数据
双向循环链表存储数据的位置，位置越靠前说明最近使用，越靠后说明最近最久未使用，
当get数据时，使用hashmap查找,找不到返回-1，找到则把该节点置换到头节点
当使用put时，使用hashmap查找,找到则更新val值且将其置换到头节点，找不到则先判断数据容量是否超过capacity,超过的话先删除最近最久未使用的节点(也就是尾节点)，随后将新
节点插入到头节点
*/
class BCListNode{
public:
BCListNode(int _key,int _val):key(_key),val(_val)
{}
 public:
 int val;
 int key;
 BCListNode* next;
 BCListNode* front;
};
class LRUCache {
private:
  int _capacity;
  BCListNode* head;
   BCListNode* tail;
   unordered_map<int,BCListNode*> mp;
public:
    LRUCache(int capacity) {
        _capacity=  capacity;    
         head=new BCListNode(0,0);
         tail=new BCListNode(0,0);
         head->next=tail;
         tail->front=head;
    }
    int get(int key) {
        if(mp.count(key))//如果存在，将对应的节点移动到头节点
        {     
            BCListNode* tmp=mp[key];
            tmp->front->next=tmp->next;
            tmp->next->front=tmp->front;
             AddToHead(tmp);
             return tmp->val;
        }
        else
        return -1;
    }
    
    void put(int key, int value) {
        if(mp.count(key)==0)  //如果该节点不存在
        {
        //将节点加到头节点
             BCListNode* newnode=new BCListNode(key,value);
             AddToHead(newnode);
              mp.insert(make_pair(key,newnode));
            //判断是否超过capacity,超过删除尾节点
            if(mp.size()==_capacity)
            {
                BCListNode* tmp=tail->front;
                tmp->front->next=tail;
                tail->front=tmp->front;
                mp.erase (tmp->key);
                delete tmp;
                AddToHead(newnode);
                mp.insert(make_pair(key,newnode));
            }
        }
        else//如果节点存在
        {
            BCListNode* tmp=mp[key];
            tmp->front->next=tmp->next;
            tmp->next->front=tmp->front;
            AddToHead(tmp);
            tmp->val=value;
        }
    }
    private:
    void  AddToHead(BCListNode* newnode)
    {
       newnode->next=head->next;
       head->next=newnode;
       head->next->front=head;
       newnode->next->front=newnode;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

