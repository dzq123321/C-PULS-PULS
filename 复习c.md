#### 1、计算机反码和补码

```
    计算机在存储时为什么存储的是补码？愿意在于计算机种，只有加法没有减法。
    例如：1 的源码是   00000000  00000000   00000000  00000001
         -1 的源码是   10000000  00000000   00000000  00000001
      我们知道 1-1是要等于0的，但如果我们源码相加，得到的是
                      10000000  00000000   00000000  00000010   =-2
        不能得到我们想要的结果0，但如果是补码的话
        正数的正反补相同
        1 的补码是   00000000  00000000   00000000  00000001
       -1 的补码是   111111111  111111111   111111111   111111111（负数的补码是反码+1，反码是符号位不变，其他的相反）补码取反加1等于源码
       补码相加      00000000  00000000   00000000  00000000
       
       
    -10  10000000  00000000   00000000   00001010
         111111111 111111111 111111111   11110101
          111111111 111111111 111111111   11110110
```

#### 2、子网掩码

```
子网掩码有两个功能：
1、查找路由 （因特网规定所有的网络必须使用子网掩码，如果不划分子网，则为默认网络号的大小），
2、子网划分（通过与子网掩码按位与可以找到子网的网络号）（划分子网增加了灵活性，减少了能够连接在网络上的主机数）
```

#### 3、虚函数的实现机制. 
```
虚函数是在类中应用的，主要是为了实现多态，在程序运行期间，如果类中有虚函数并实例化了一个对象，则这个对象的首部四位是一个指针，这是一个指针数组指针，一个指向指针数组的指针，这个指针数组就是我们所说的虚函数表，数组里面存放的是各个虚函数的地址（函数指针）。当有子类继承父类的时候，如果子类没有虚函数，则子类中存在一个和父类一样的虚表，如果子类存在虚函数并对父类的虚函数进行的重写，则父类相应位置的虚函数指针变为子类的虚函数指针。其他的按声明的顺序排列。
```
#### 4、结构体对齐
```
结构体需要字节对齐，vs默认的对齐数位8，linux为4字节对齐，
从结构体的第一个成员开始，每个成元需要对齐的字节数都是要对齐到对齐数的整数倍
对齐数是（它自身的大小和默认大小8中的最小值进行比较）
最后总大小需要是最大对齐数的整数倍
struct S
{
char c1;  //对齐数为1  所以为  0-》0   1
char c2;  //对齐数为1  偏移量为1 所以为  1-》1    1
int i;    //对齐数为4，偏移量为2，便宜量要为4的倍数，1+1+2，从第四个地址开始  所以为  4-》7 总的偏移量为8
}
offsetof  计算结构体元素距首地址的偏移量
自定义offsetof（他是一个宏）
#define   Offsetof(s,m)   size_t (( &((S*)0)->m))  
struct S
{
	char a;//0
	char b;//1
	int c;//4
}stu;
int main()
{
	printf("%d \n",Offsetof(struct S,a));
	printf("%d \n",Offsetof(struct S,b));
	printf("%d \n",Offsetof(struct S,c));
}
```
####5、Linux  c程序被处理的过程
```
一个c程序被处理的过程
(1) 预编译    gcc -E test.c  -o test.i
                     （删除注释，宏替换，头文件展开，条件编译）
(2)编译       gcc -S test.o  -o test.s
                                 （将c程序变为汇编语言）
(3)汇编        gcc -c test.s  -o test.o
                       （简化汇编语言变为二进制语言，还不能直接被计算器读取） （1,2,3统称编译）
(4)链接        (可执行程序)
静态链接 ：指程序在编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时不再需要库文件，运行得比较快，一般以" .a "为后缀
动态链接： 指程序在编译链接时，没有把库文件的代码全部加入到可执行文件中，而是在程序执行时链接文件到加载库，这样节省了系统的开销，一般以 " .so "为后缀.
gcc默认动态链接 （不能独立运行，需要加载库）
 vim  编辑器
gcc  编译器（编译完默认的是release模式）所以无法直接调试
gbd  调试器      （使用方法： 先gcc test.c -o  mytest.c  -g     在gdb mytest.c）
```

#### 6、inline函数

```
1、inline函数主要是增加编译器运行的效率，主要适合那些体积小，但又需要经常调用的函数。
2、inline函数原理就是在编译期间就将函数内嵌到程序中，而普通函数是只有在需要使用的时候才调用。所以有inline的函数都比较大。
3、inline不是用户想使用就使用，还是要看编译器是怎么判断的。
4、类内定义的成员方法默认是inline的，而如果想在类内声明，类外定义，在类外定义的时候需要加inline关键字（也就是说在inline必须在函数定义处加，而不能在函数声明的加）。
5、inline和宏类似，但比宏安全
```

#### 7、main函数之前可以执行的操作

```
1、全局(静态)的变量，全局(静态)的对象的中构造函数和拷贝构造函数。这是因为全局变量和静态变量的生命周期是程序运行期一直存在。
2、gcc中用_attribute_关键字修饰的constructor/destructor._attribute_是修改属性的，constructor属性设置函数在所有函数之前执行，destructor设置函数在所有函数退出后执行。
```

#### 8、HTTPS为什么安全? 

```
（总体来说，是因为HTTPS对HTTP报文的数据进行了加密）我们知道HTTP是一种明文协议，客户或服务器发送的数据基本上实在网络上裸奔。可以想到对数据进行加密，这时我们引入HTTPS,他是在应用层和传输层之间的一种协议，主要用于对数据加密，有SSL和TLS,现在主要使用TLS协议，是要经过四次握手的协议，HTTPS是要经历两次加密，一次是非对称加密对数据加密，这时客户端要把非对称加密的报文发送到服务器段，又要使用非对称加密计算对对称加密的密钥进行加密。所以服务器端要向客户端发送非对称加密的公钥。
```

![https](E:\duzhiqiang\比特51c语言\github\picture\https.png)

#### 9、.c与.cpp如何混合编程, 为什么需要extern “C”? 

```c++
我们都知道，在函数编译的时候系统会在底层从新为函数命名，而在c文件和cpp文件中文件的命名规则是不一样的，这是因为cpp文件存在函数重载的情况。
 一：//C++引用C函数的例子(C++调用C，extern "C" 的作用是：让C++连接器找调用函数的符号时采用C的方式 如)
//test.c
#include<stdio.h>
void mytest()
{
   printf("mytest in .c file ok\n");
}
//main.cpp
#include<iostream>
extern "C"
{
   void mytest();
}
int main()
{
      mytest();
      return 0;
}
二：//在C中引用C++函数(C调用C++，使用extern "C"则是告诉编译器把cpp文件中extern "C"定义的函数依照C的方式来编译封装接口，当然接口函数里面的C++语法还是按C++方式编译)
    //test.cpp
#include<iostream>
extern "C"
{
  void mytest()
  {
    printf("mytest in .cpp file ok\n");
  }
}
//main.c
#include<stdio.h>
void mytest();
int main()
{
   mytest();
   return 0;
}
但我们一般都是将函数定义在头文件，而无论是c或cPP实现，都要被c或CPP调用，所以在定义函数时，需要加入宏
分为两种情况，
1、在cpp中调用c的函数
#include<iostream>
#ifdef _CPPPLUSPLUS
extern "c" {
#endif // _CPPPLUSPLUS
#include"t5.h"
#include"t5.c"
	int add(int a, int b);
#ifdef _CPPPLUSPLUS
}
#endif // _CPPPLUSPLUS

#include<stdlib.h>
using namespace std;
int main()
{	
	cout << add(3, 4) << endl;
}

2、在c中调用cpp的函数
//t5.h
#ifdef __cplusplus
#include<stdio.h>
extern "C"
{
#endif
	void mytest();
#ifdef __cplusplus
}
#endif
//t6.cpp
#include"t5.h"
#include<iostream>
using namespace std;
	void mytest()
	{
		cout << "mytest in .cpp file ok\n" << endl;
	}

//t5.c
#include<stdio.h>
#include"t5.h"
void mytest();
int main()
{
	mytest();
	return 0;
}

```

